---
title: "Rapport de laboratoire 2"
subtitle: "MTH8408"
author:
  - name: Esse Dawut
    email: dawut.esse@polymtl.ca
    affiliation:
      - name: Polytechnique Montréal
format:
  pdf:
    keep-tex: false
    documentclass: article
    include-in-header:
      - text: |
            \usepackage{eulervm}
            \usepackage{xspace}
            \usepackage[francais]{babel}
    geometry:
      - margin=1in
    papersize: letter
    colorlinks: true
    urlcolor: blue
engine: julia
---

```{julia}
#| output: false
using Pkg
Pkg.activate("labo2_env")
using LinearAlgebra
using Random
using Printf
Pkg.add("PrettyTables")
using PrettyTables: pretty_table, ft_printf
```

# Contexte

Dans ce laboratoire, on demande d'implémenter deux méthodes itératives pour résoudre
$$
  \min_x \ g^T x + \tfrac{1}{2} x^T H x
$$ {#eq-qp}
où $g \in \mathbb{R}^n$ et $H$ est une matrice $n \times n$ symétrique et définie positive.

# Question 1

En cours, nous avons vu la méthode de la plus forte pente avec recherche linéaire exacte pour résoudre ([-@eq-qp]).

Dans cette question, on demande d'implémenter et de tester cette méthode sur divers objectifs quadratiques convexes.

Votre implémentation doit avoir les caractéristiques suivantes :

1. un critère d'arrêt absolu et relatif sur le gradient de l'objectif ;
2. un critère d'arrêt portant sur le nombre d'itérations (le nombre maximum d'itérations devrait dépendre du nombre de variables $n$ du problème) ;
3. allouer un minimum en utilisant les opérations vectorisées (`.=`, `.+`, `.+=`, etc.) autant que possible ;
4. calculer *un seul* produit entre $H$ et un vecteur par itération ;
5. n'utiliser $H$ qu'à travers des produits avec un vecteur (ne pas accéder aux éléments de $H$ ou indexer dans $H$) ;
5. ne dépendre que de `LinearAlgebra`.
6. votre fonction principale doit être documentée---reportez-vous à [https://docs.julialang.org/en/v1/manual/documentation](https://docs.julialang.org/en/v1/manual/documentation) ;
7. votre fonction doit faire afficher les informations pertinentes à chaque itération sous forme de tableau comme vu en cours.

Tester votre implémentation sur les problèmes quadratiques de la section *Problèmes test* ci-dessous.

```{julia}
function steepest_qp(g, H; eps_a = 1e-5, eps_r = 1e-5,
                     max_iter = length(g))
    n        = length(g)
    x        = zeros(eltype(g), n)        # x₀ = 0
    r        = g + H*x                    # gradient
    r0       = norm(r)
    tol      = eps_a + eps_r * r0
    q        = 0.0

    @printf("%4s  %12s  %12s\n", "k", "‖∇q(x)‖", "q(x)")
    @printf("%4d  %12.4e  %12.4e\n", 0, r0, q)

    for k in 1:max_iter
        p  = -r
        Hp = H * p
        α  = dot(r, r) / dot(p, Hp)       # pas exact
        x .+= α * p

        # mise‑à‑jour « gratuite » de q(x)
        q += 0.5 * α * dot(r, p)

        # gradient au nouvel x : r ← r + α H p
        r .+= α * Hp
        rnorm = norm(r)

        @printf("%4d  %12.4e  %12.4e\n", k, rnorm, q)

        if rnorm ≤ tol
            return x, k, q
        end
    end
    return x, max_iter, q
end
```

# Question 2

Dans cette question, on demande d'implémenter la méthode BFGS pour résoudre le problème quadratique convexe ([-@eq-qp]).

Votre implémentation doit avoir les mêmes caractéristiques qu'à la question 1.

Ici, on cherche notamment à valider le résultat disant que la méthode se termine en au plus $n$ itérations (en arithmétique exacte) et reconstruit $H$, c'est-à-dire que $B_k = H$ à la convergence.

Tester votre implémentation sur les problèmes quadratiques de la section *Problèmes test* ci-dessous.

```{julia}
function bfgs_qp(g, H; eps_a = 1e-5, eps_r = 1e-5, max_iter = length(g))
    n    = length(g)
    x    = zeros(eltype(g), n)
    r    = g + H*x                       # gradient ∇q(x₀)
    r0   = norm(r)
    tol  = eps_a + eps_r * r0
    q    = 0.0                           # q(x₀) = 0 (car x₀ = 0)
    B    = Matrix{eltype(g)}(I, n, n)    # identité flottante

    @printf("%4s  %12s  %13s\n", "k", "‖∇q(x)‖", "q(x)")
    @printf("%4d  %12.4e  %13.6e\n", 0, r0, q)

    for k in 1:max_iter
        p  = -B \ r
        Hp = H * p
        α  = -(r' * p) / (p' * Hp)       # pas exact

        s  = α * p
        x .+= s
        q += 0.5 * α * (r' * p)          # mise‑à‑jour « gratuite »

        r_new = r + α * Hp
        y     = r_new - r
        sy    = dot(s, y)

        # test de petite courbure
        if sy ≤ 1e-12
            r = r_new
            break
        end

        # mise à jour BFGS
        Bs = B * s
        B .+= (y*y') / sy - (Bs*Bs') / dot(s, Bs)

        r = r_new
        rnorm = norm(r)
        @printf("%4d  %12.4e  %13.6e\n", k, rnorm, q)

        # critère d’arrêt explicite
        if rnorm ≤ tol
            return x, k, q
        end
    end
    return x, max_iter, q
end
```

# Résultats numériques

## Problèmes test

Votre premier problème test sera généré aléatoirement avec $n = 10$.

```{julia}
n = 10
Random.seed!(42)
A = randn(n, n)                       
g_rand = randn(n)
H_rand = Symmetric(A' * A + I)            # SPD
@printf("\n—— STEEPEST‑DESCENT (random n = 10) ——\n")
x_sd, its_sd = steepest_qp(g_rand, H_rand)

@printf("\n——   BFGS OPTIMISÉ (random n = 10) ——\n")
x_bfgs, its_bfgs = bfgs_qp(g_rand, H_rand)
```

Utiliser ensuite les problèmes quadratiques convexes de la collection Maros et Meszaros.
Vous pouvez y accéder à l'aide de l'extrait de code suivant :
```{julia}
#| output: false
Pkg.add("QPSReader")  # collection + outils pour lire les problèmes

using QPSReader
using Logging
using SparseArrays

function get_gH(name, reg=0)
  mm_path = fetch_mm()  # chemin vers les problèmes sur votre disque
  qpdata = with_logger(Logging.NullLogger()) do
    readqps(joinpath(mm_path, name))
  end
  n = qpdata.nvar
  g = qpdata.c
  H = Symmetric(sparse(qpdata.qrows, qpdata.qcols, qpdata.qvals, n, n) + reg * I, :L)
  return g, H
end
```

Les noms des problèmes sont listés sur [https://bitbucket.org/optrove/maros-meszaros/src/master/](https://bitbucket.org/optrove/maros-meszaros/src/master/).

Leurs dimensions sont donnés dans le tableau sur la page [https://www.doc.ic.ac.uk/~im/00README.QP](https://www.doc.ic.ac.uk/%7Eim/00README.QP) (avec des noms qui ne correspondent pas tout à fait ; les noms corrects sont ceux de la page Bitbucket).

NB : ces problèmes ont des contraintes, mais dans ce laboratoire, on les ignore.

Choisissez 3 problèmes :

* un avec $n \approx 10$ ;
* un avec $n \approx 50$ ;
* un avec $n \approx 100$.

```{julia}
g10, H10 = get_gH("GENHS28.SIF")
g50, H150 = get_gH("DUAL4.SIF")
g100, H100 = get_gH("CVXQP1_S.SIF")
@show length(g10)
@show length(g50)
@show length(g100)
```

Attention :

* il se peut que $g = 0$---dans ce cas, changez $g$ en `ones(n)` ;
* il se peut que $H$ soit seulement semi-définie positive et pas définie positive---dans ce cas, ajoutez-lui un petit multiple de l'identité via, par exemple,

```{julia}
g, H = get_gH("GENHS28.SIF", 1.0e-3)
```

## Validation de la méthode de la plus forte pente

```{julia}
# votre code ici
cases = [
    ("GENHS28.SIF", "≈10"),    # tag = texte explicatif
    ("DUAL4.SIF",   "≈50"),
    ("CVXQP1_S.SIF","≈100")
]
results = Vector{Tuple}()

for (names,tag) in cases
    g, H = get_gH(names, 1e-3)

# ---> correction si g est nul
    if all(g .== 0)
        g .= ones(length(g))
    end

    @printf("\n=== Problème  %s  (tag %s, n=%d) ===\n",
            names, tag, length(g))

     x_sd,  it_sd,  q_sd   = steepest_qp(g, H)          # Steepest‑Descent
     grad_sd               = norm(H*x_sd + g)
    
     push!(results,
           (names, tag, it_sd, grad_sd, q_sd,))
end

# convertir chaque tuple en Vector et empiler en lignes
data = [collect(t) for t in results]          # Vector{Vector}
data_mat = permutedims(hcat(data...))
# -------- Tableau récapitulatif ----------------------------------------
pretty_table(data_mat;
    header = ["cas", "taille","it‑SD", "‖∇q‖_SD", "q_SD"],
    formatters = ft_printf("%.4e", 4:5))
```

## Validation de la méthode BFGS

```{julia}
# votre code ici
cases = [
    ("GENHS28.SIF", "≈10"),    # tag = texte explicatif
    ("DUAL4.SIF",   "≈50"),
    ("CVXQP1_S.SIF","≈100")
]
results = Vector{Tuple}()

for (names,tag) in cases
    g, H = get_gH(names, 1e-3)

    if all(g .== 0)
        g .= ones(length(g))
    end

    @printf("\n=== Problème  %s  (tag %s, n=%d) ===\n",
            names, tag, length(g))


    x_bfgs, it_bfgs, q_bg = bfgs_qp(g, H)              # BFGS
    grad_bfgs             = norm(H*x_bfgs + g)

    push!(results,
          (names, tag,it_bfgs, grad_bfgs, q_bg))
    
end
# convertir chaque tuple en Vector et empiler en lignes
data = [collect(t) for t in results]          # Vector{Vector}
data_mat = permutedims(hcat(data...))
# -------- Tableau récapitulatif ----------------------------------------
pretty_table(data_mat;
    header = ["cas", "taille","it‑BFGS", "‖∇q‖_BFGS", "q_BFGS"],
    formatters = ft_printf("%.4e", 4:5))
```
